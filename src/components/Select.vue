<style>
	.v-select {
		position: relative;
		/* Fix behavior in tables */
    display: table;
    table-layout: fixed;
    width: 100%;
	}

	.v-select .disabled {
		cursor: not-allowed !important;
		background-color: rgb(248, 248, 248) !important;
	}

	.v-select .clear > span {
		height: 26px;
    position: absolute;
    top: 6px;
    right: 14px;
    width: 20px;
	}

	.v-select .open-indicator {
		position: absolute;
		bottom: 6px;
		right: 10px;
		display: inline-block;
		cursor: pointer;
		pointer-events: all;
		transition: all 150ms cubic-bezier(1.000, -0.115, 0.975, 0.855);
		transition-timing-function: cubic-bezier(1.000, -0.115, 0.975, 0.855);
		opacity: 1;
		transition: opacity .1s;
	}

	.v-select.loading .open-indicator {
		opacity: 0;
	}

	.v-select .open-indicator:before {
		border-color: rgba(60, 60, 60, .5);
		border-style: solid;
		border-width: 0.25em 0.25em 0 0;
		content: '';
		display: inline-block;
		height: 10px;
		width: 10px;
		vertical-align: top;
		transform: rotate(133deg);
		transition: all 150ms cubic-bezier(1.000, -0.115, 0.975, 0.855);
		transition-timing-function: cubic-bezier(1.000, -0.115, 0.975, 0.855);
	}

	.v-select.open .open-indicator {
		bottom: 1px;
	}

	.v-select.open .open-indicator:before {
		transform: rotate(315deg);
	}

	.v-select .dropdown-toggle {
		display: block;
		padding: 0;
		background-color: white;
		border: 1px solid rgba(60, 60, 60, .26);
		border-radius: 4px;
		white-space: nowrap;
		overflow: hidden;
	}

	.v-select.searchable .dropdown-toggle {
		cursor: text;
	}

	.v-select.open .dropdown-toggle {
		border-bottom: none;
		border-bottom-left-radius: 0;
		border-bottom-right-radius: 0;
	}

	.v-select > .dropdown-menu {
		margin: 0;
		width: 100%;
		overflow-y: auto;
		border-top-left-radius: 0;
	}

	.v-select > .dropdown-menu-simple {
		margin: 0;
		width: 100%;
		overflow-y: auto;
		border-top: none;
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}

	.v-select .selected-tag {
		color: #333;
	  margin: 3px 1px 0 3px;
		padding: 0 0.25em;
		float: left;
		line-height: 1.7em;
		overflow: hidden;
		text-overflow: ellipsis;
	}

	.v-select .selected-tag.single {
		max-width: calc(100% - 20px - 2em);
		text-align: left;
	}

	.v-select .selected-tag-content {
		display: block;
		text-overflow: ellipsis;
		overflow: hidden;
	}

	.v-select .selected-tag.multiple {
		background-color: #f0f0f0;
		border: 1px solid #ccc;
		border-radius: 4px;
	}

	.v-select .selected-tag .close {
		float: none;
		margin-right: 0;
	}

	.v-select input[type=search],
	.v-select input[type=search]:focus {
		display: inline-block;
		border: none;
		outline: none;
		margin: 0;
		padding: 0 .5em;
		width: 10em;
		max-width: 100%;
		background: none;
		position: relative;
		box-shadow: none;
		float: left;
		clear: none;
	}

	.v-select input[type=search]:disabled {
		cursor: pointer;
	}

	.v-select li a {
		cursor: pointer;
	}

	.v-select .active a {
		background: rgba(50, 50, 50, .1);
		color: #333;
	}

	.v-select .highlight a,
	.v-select li:hover > a {
		background: #f0f0f0;
		color: #333;
	}

	.v-select .spinner {
		position: absolute;
		top: 1em;
    right: 4em; /* 7em when selected a value and not multiple */
		font-size: 5px;
		text-indent: -9999em;
		overflow: hidden;
		border-top: .9em solid rgba(100, 100, 100, .1);
		border-right: .9em solid rgba(100, 100, 100, .1);
		border-bottom: .9em solid rgba(100, 100, 100, .1);
		border-left: .9em solid rgba(60, 60, 60, .45);
		transform: translateZ(0);
		animation: vSelectSpinner 1.1s infinite linear;
		transition: opacity .1s;
	}

	.v-select .spinner.shifted-left {
		right: 7em;
	}

	.v-select .spinner,
	.v-select .spinner:after {
		border-radius: 50%;
		width: 4em;
		height: 4em;
	}

	@-webkit-keyframes vSelectSpinner {
		0% {
			transform: rotate(0deg);
		}
		100% {
			transform: rotate(360deg);
		}
	}

	@keyframes vSelectSpinner {
		0% {
			transform: rotate(0deg);
		}
		100% {
			transform: rotate(360deg);
		}
	}
</style>

<template>
	<div class="dropdown v-select" :class="dropdownClasses">
		<div @mousedown.prevent.stop="toggleDropdown" ref="toggle" :class="['dropdown-toggle', 'clearfix', {'disabled': disabled}]" type="button">

        <div :class="selectedTagClasses" v-for="option in mutableValues" v-bind:key="option.index" v-show="!focused || multiple">
					<div class="selected-tag-content">
						<slot name="selected" :data="option">
							{{ option[valueField] }}
						</slot>
					</div>
          <button v-show="multiple && allowClear" @click.prevent.stop="toggle(option)" type="button" class="close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>

			<input
							ref="search"
							:debounce="debounce"
							v-model="search"
							@keydown.delete="maybeDeleteValue"
							@keydown.up.prevent="typeAheadUp"
							@keydown.down.prevent="typeAheadDown"
							@keyup.enter.prevent.stop="typeAheadSelect"
							@keydown.enter.prevent.stop
							@blur="onBlur"
							@focus="onFocus"
							@mousedown.prevent.stop="toggleDropdown"
							type="search"
							:name="name"
							:disabled="disabled"
              :class="[{'disabled': disabled}, 'form-control']"
							:maxlength="maxlength"
							:placeholder="placeholder"
							:readonly="!searchable"
							:style="{ width: isValueEmpty || focused ? 'calc(100% - 20px - 2em)' : '2em' }"
			>

			<button v-show="!multiple && !isValueEmpty && allowClear" @click.prevent.stop="clear" tabIndex="-1" type="button" class="close clear">
				<span aria-hidden="true">&times;</span>
			</button>

			<div ref="openIndicator" :class="[{'disabled': disabled}, 'open-indicator-container']">
				<slot name="open-indicator">
					<i role="presentation" class="open-indicator"></i>
				</slot>
			</div>

			<slot name="spinner">
				<div :class="spinnerClasses" v-show="mutableLoading">Loading...</div>
			</slot>
		</div>

		<ul ref="dropdownMenu" v-show="open && !disabled" :transition="transition" :class="dropdownMenuClasses" :style="{ 'max-height': maxHeight, 'min-width': minWidth }" @mousewheel="scroll" @scroll="scroll">
			<li v-for="(option, index) in filteredOptions" v-bind:key="index" :class="{ active: isOptionSelected(option), highlight: index === typeAheadPointer }" @mouseover="typeAheadPointer = index">
				<a @click.prevent.stop="toggle(option)" @mousedown.prevent.stop>
					<slot name="item" :data="option">
						{{ option[valueField] }}
					</slot>
				</a>
			</li>
			<transition name="fade">
				<li v-if="!filteredOptions.length && minWidth == '0'" class="divider"></li>
			</transition>
			<transition name="fade">
				<li v-if="!filteredOptions.length" class="text-center no-data">
					<slot name="no-options">Sorry, no matching options.</slot>
				</li>
			</transition>
		</ul>
	</div>
</template>


<script type="text/babel">
	import pointerScroll from '../mixins/pointerScroll'
	import typeAheadPointer from '../mixins/typeAheadPointer'
	import ajax from '../mixins/ajax'

	export default {
		mixins: [pointerScroll, typeAheadPointer, ajax],

		props: {

			disabled: {
				type: Boolean,
				default: false
			},

			name: {
				type: String,
				default: ''
			},

			allowClear: {
				type: Boolean,
				default: true
			},

			/**
			 * Contains the currently selected values.
			 * @type {Object}
			 */
			values: {
				default() {
					return []
				}
			},

			/**
			 * The name of the attribute inside the values used to
			 * distinguish them
			 */
			valueField: {
				default: 'value'
			},

			/**
			 * The name of the attribute inside the values used to
			 * filter them
			 */
			filterField: {
				default: 'value'
			},

			/**
			 * Maximum text search input length in characters
			 */
			maxlength: {
				default: 255
			},

			/**
			 * An array of objects to be used as dropdown choices.
			 */
			options: {
				type: Array,
				default() {
					return []
				},
			},

			/**
			 * Sets the max-height property on the dropdown list.
			 * @deprecated
			 * @type {String}
			 */
			maxHeight: {
				type: String,
				default: '400px'
			},

			/**
			 * Sets the min-width property on the dropdown list.
			 * @type {String}
			 */
			minWidth: {
				type: String,
				default: '0'
			},

			/**
			 * A callback function that will be
			 * run when the dropdown has a scrollbar and
			 * is scrolled to the bottom.
			 */
			onScrollEnd: {
				type: Function,
				default: function() {
					if (this.onSearch) this.onSearch(this.search, this.toggleLoading, this.typeAheadPointer)
				}
			},

			/**
			 * A callback function that will be
			 * run when the dropdown is closing.
			 */
			onCloseDropdown: {
				type: Function,
				default: function(){}
			},

			/**
			 * Enable/disable filtering the options.
			 * @type {Boolean}
			 */
			searchable: {
				type: Boolean,
				default: true
			},

			buildPlaceholder: {
				type: Function,
				default: function(data){
					return data ? '' + data[this.valueField] : ''
				}
			},

			/**
			 * Equivalent to the `multiple` attribute on a `<select>` input.
			 * @type {Object}
			 */
			multiple: {
				type: Boolean,
				default: false
			},

			/**
			 * Sets a Vue transition property on the `.dropdown-menu`. vue-select
			 * does not include CSS for transitions, you'll need to add them yourself.
			 * @type {String}
			 */
			transition: {
				type: String,
				default: 'expand'
			},

			/**
			 * Enables/disables clearing the search text when an option is selected.
			 * @type {Boolean}
			 */
			clearSearchOnSelect: {
				type: Boolean,
				default: true
			},

			/**
			 * An optional callback function that is called each time the selected
			 * value(s) change. When integrating with Vuex, use this callback to trigger
			 * an action, rather than using :value.sync to retreive the selected value.
			 * @type {Function}
			 * @default {null}
			 */
			onChange: {
				type: Function,
				default: function(val) {
					this.$emit('input', val)
				}
			},

			/**
			 * Enable/disable creating options from searchInput.
			 * @type {Boolean}
			 */
			taggable: {
				type: Boolean,
				default: false
			},

			/**
			 * When true, newly created tags will be added to
			 * the options list.
			 * @type {Boolean}
			 */
			pushTags: {
				type: Boolean,
				default: false
			},

			/**
			 * When false, updating the options will not reset the select value
			 * @type {Boolean}
			 */
			resetOnOptionsChange: {
				type: Boolean,
				default: false
			},
		},

		data() {
			return {
				search: '',
				focused: false,
				open: false,
				mutableValues: [],
				mutableOptions: [],
				mutableLoading: false
			}
		},

		watch: {
			/**
			 * When the value prop changes, update
			 * the internal mutableValues.
			 * @param  {mixed} val
			 * @return {void}
			 */
			values(val) {
				this.mutableValues = val
			},

			search(val) {
				if (val) this.open = true
			},

			/**
			 * Maybe run the onChange callback.
			 * @param  {string|object} val
			 * @param  {string|object} old
			 * @return {void}
			 */
			mutableValues(val, old) {
				if (this.multiple) {
					this.onChange ? this.onChange(val) : null
				} else {
					this.onChange && val !== old ? this.onChange(val) : null
				}
			},

			/**
			 * When options change, update
			 * the internal mutableOptions.
			 * @param  {array} val
			 * @return {void}
			 */
			options(val) {
				this.mutableOptions = val
			},

			/**
			 * Maybe reset the mutableValues
		 	 * when mutableOptions change.
			 * @return {[type]} [description]
			 */
			mutableOptions() {
				if (!this.taggable && this.resetOnOptionsChange) {
					this.mutableValues = []
				}
			},

			/**
			 * Always reset the mutableValues when
			 * the multiple prop changes.
			 * @param  {Boolean} val
			 * @return {void}
			 */
			multiple(val) {
				this.mutableValues = []
 			},

			open(val, old) {
				if (val != old) {
					if(this.open) {
						 this.focus()
						 if(this.onSearch) this.onSearch(this.search, this.toggleLoading)
					} else {
						this.search = ''
						this.onCloseDropdown()
					}
				}
			}
		},

		created() {
			this.mutableValues = this.mutableValues
			this.mutableOptions = this.options.slice(0)
			this.mutableLoading = this.loading
		},

		methods: {

			onFocus() {
				this.focused = true
			},

			onBlur() {
				this.focused = false
				this.open = false
			},

		/**
		 * puts the focus on the input field.
		 */
			focus() {
				if (!this.disabled && document.activeElement !== this.$refs.search) {
					this.$refs.search.focus()
				}
			},

			/**
			 * Toggle a given option.
			 * @param  {Object} option
			 * @return {void}
			 */
			toggle(option) {
				if (this.isOptionSelected(option) && this.allowClear) {
					this.deselect(option)
				} else {
					this.select(option)
				}
			},

			clear() {
				this.mutableValues = []
			},

			/**
			 * Select a given option
			 * @param  {Object} option
			 * @return {void}
			 */
			select(option) {
				if (this.multiple) {
					this.mutableValues.push(option)
				} else {
					this.mutableValues = [option]
				}
				this.onAfterSelect(option)
			},

			/**
			 * De-select a given option.
			 * @param  {Object} option
			 * @return {void}
			 */
			deselect(option) {
				if (this.multiple) {
					let ref = -1
					this.mutableValues.forEach(val => {
						if (val[this.valueField] === option[this.valueField]) {
							ref = val
						}
					})
					var index = this.mutableValues.indexOf(ref)
					this.mutableValues.splice(index, 1)
				} else {
					this.mutableValues = []
				}
			},

			/**
			 * Called from this.select after each selection.
			 * @param  {Object|String} option
			 * @return {void}
			 */
			onAfterSelect(option) {
				if (this.clearSearchOnSelect) {
					this.search = ''
				}
				if (!this.multiple) {
					this.open = false
				}
			},

			/**
			 * Handles dropdown scroll. Calls onScrollEnd when
			 * the dropdown is scrollable and scrolled to the
			 * bottom.
			 */
			scroll(event) {
        var elem = event.currentTarget;
				this.checkIfScrolledToEnd(elem);
			},

			handleMouseWheel(event) {
				// https://jsfiddle.net/tovic/6nFTC/
        var elem = event.currentTarget
		    var delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail)))
				if (delta < 0) this.checkIfScrolledToEnd(elem)
			},

			checkIfScrolledToEnd(elem) {
				if (elem.scrollHeight != this.prevScrollHeight && elem.scrollHeight - elem.scrollTop <= elem.offsetHeight) {
					this.prevScrollHeight = elem.scrollHeight
					this.onScrollEnd()
        }
			},

			/**
			 * Toggle the visibility of the dropdown menu.
			 * @param  {Event} e
			 * @return {void}
			 */
			toggleDropdown(e) {
				if (this.open || this.disabled) {
					this.open = false
				} else {
					this.open = true
				}
			},

			/**
			 * Check if the given option is currently selected.
			 * @param  {Object|String}  option
			 * @return {Boolean}        True when selected | False otherwise
			 */
			isOptionSelected(option) {
				if (this.mutableValues !== null && this.mutableValues !== undefined) {
					let selected = false
					this.mutableValues.forEach(opt => {
						if (opt[this.valueField] === option[this.valueField]) {
							selected = true
						}
					})
					return selected
				}
				return false
			},

			/**
			 * Delete the value on Delete keypress when there is no
			 * text in the search input, & there's tags to delete
			 */
			maybeDeleteValue() {
				if (this.allowClear && this.$refs.search.value.length === 0 && this.mutableValues.length > 0) {
					this.deselect(this.mutableValues[this.mutableValues.length-1])
				}
			},

			/**
			 * Determine if an option exists
			 * within this.mutableOptions array.
			 *
			 * @param  {Object || String} option
			 * @return {boolean}
			 */
			optionExists(option) {
				return this.mutableOptions
					.filter(opt => opt[this.valueField] === option.valueField)
					.length > 0
			}
		},

		computed: {

			placeholder() {
				if (this.focused) {
					return this.buildPlaceholder(this.mutableValues.length > 0 ? this.mutableValues[0] : null)
				} else {
					return ''
				}
			},

		/**
		 * Classes to be output on selected tags
		 * @return {Object}
		 */
			selectedTagClasses() {
				return {
					'selected-tag': true,
					multiple: this.multiple,
					single: !this.multiple
				}
			},

 			spinnerClasses() {
 				return {
 					'spinner': true,
 					'shifted-left': !this.isValueEmpty && !this.multiple,
 					single: !this.multiple
 				}
 			},

			/**
			 * Classes to be output on .dropdown
			 * @return {Object}
			 */
			dropdownClasses() {
				return {
					open: this.open,
					searchable: this.searchable,
					loading: this.mutableLoading
				}
			},

			/**
			 * @return {Object}
			 */
			dropdownMenuClasses() {
				return {
					'dropdown-menu-simple': this.minWidth == '0',
					'dropdown-menu': true
				}
			},

			/**
			 * The currently displayed options, filtered
			 * by the search elements value. If tagging
			 * true, the search text will be prepended
			 * if it doesn't already exist.
			 *
			 * @return {array}
			 */
			filteredOptions() {
				let search = this.search.toLowerCase()
				let options = this.mutableOptions.filter(option => {
					if (typeof option[this.filterField] === 'string' && (!this.onSearch || this.mutableLoading)) {
						return option[this.filterField].toLowerCase().indexOf(search) > -1
					} else {
						return true;
					}
				})
				if (this.taggable && search.length && !this.optionExists(search)) {
					options.unshift(search)
				}
				return options
			},

			selectedOptions() {
				return this.mutableOptions.filter(this.isOptionSelected, this)
			},

			/**
			 * Check if there aren't any options selected.
			 * @return {Boolean}
			 */
			isValueEmpty() {
				if (this.mutableValues.length === 0) {
					return true;
				}
				return this.mutableValues
					.filter(val => val[this.valueField] !== undefined)
					.length === 0
			},
		},

	}
</script>
